#!/bin/bash

################################################################################
# Doily v0.1.2
# https://github.com/relsqui/doily
#
# (c) 2017 Finn Ellis.
# You are free to use, copy, modify, etc. this by the terms of the MIT license.
# See included LICENSE.txt for details.
#
# A script for managing daily writing. See README.md or `doily help`.
################################################################################

set -e

VERSION="0.1.2"

# This complies with the XDG Base Directory Specification:
# https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html
CONF_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/doily"
CONF_FILE="${CONF_DIR}/doily.conf"
DEFAULT_CONF="${DOILY_TEST_ETC:-/usr/local/etc}/doily/default.conf"

read ECONFIG ESTORAGE ECOMMAND EDATE <<< $(seq 4)

command_config() {
    ############################################################################
    # Opens the user's personal configuration file in their preferred editor.
    #
    # Globals:
    #    - CONF_FILE
    # Environment:
    #    - EDITOR
    # Args:
    #    - None.
    # Returns:
    #    - None.
    ############################################################################
    "${EDITOR:-nano}" "${CONF_FILE}"
}

command_help() {
    ############################################################################
    # Prints doily's help text.
    #
    # Args:
    #    - None.
    # Returns:
    #    - None.
    ############################################################################
    cat <<EOF
Doily: a daily writing manager.
https://github.com/relsqui/doily

Usage: doily [command] [arguments ...]

Commands:
    config         - Edit your personal configuration file.
    help           - Print this help.
    read [d]       - Read the entry for a given [d]ay. Days are accepted in any
                     format \`date\` understands, from "Feb 18" to "2017/02/18"
                     to "last week" (see \`date\` documentation for specifics).
                     The date "last" is also a special case interpreted as "the
                     most recent entry, whenever it was," which is the default.
    search [p] [d] - Search for a [p]attern (an extended regex) in the
                     specified [d]ay. The default pattern is empty. Days can be
                     specified as for reading; the default is all entries.
    version        - Print the installed version number of Doily.
    write          - Open today's file for writing. This is the default command
                     if no other one is specified.
EOF
}

command_read() {
    ############################################################################
    # Opens a daily file in the user's preferred pager.
    #
    # Config Vars:
    #    - doily_dir
    # Environment:
    #    - PAGER
    # Args:
    #    - An identifier for the daily to be read. This should be either the
    #      string "last" (meaning the most recent file) or a value which can
    #      be interpreted by `date`. Defaults to "last".
    # Returns:
    #    - EDATE if the daily couldn't be identified.
    ############################################################################
    if [[ -z "$1" ]]; then
        target="$(identify_dailyfile last)"
    else
        target="$(identify_dailyfile "$1")"
    fi
    if [[ -z "${target}" ]]; then
        echo "Couldn't find a daily corresponding to that date."
        return "$EDATE"
    fi
    "${PAGER:-less}" "${doily_dir}/${target}"
}

command_search() {
    ############################################################################
    # Search past daily files for a regular expression.
    #
    # Config Vars:
    #    - doily_dir
    # Args:
    #    - The pattern to search for (required but can be empty).
    #    - An identifier for the daily to search. This should be either the
    #      string "last" (meaning the most recent file) or a value which can
    #      be interpreted by `date`. Defaults to searching all files.
    # Returns:
    #    - EDATE if the daily couldn't be identified.
    ############################################################################
    if [[ -z "$2" ]]; then
        egrep "$1" "${doily_dir}"/*
        return
    fi
    target="$(identify_dailyfile "$2")"
    if [[ -z "${target}" ]]; then
        echo "Couldn't find a daily corresponding to that date."
        return "$EDATE"
    fi
    egrep "$1" "${doily_dir}/${target}"
}

command_version() {
    ############################################################################
    # Prints the current Doily version number.
    #
    # Globals:
    #    - VERSION
    # Args:
    #    - None.
    # Returns:
    #    - None.
    ############################################################################
    echo "doily v${VERSION}"
}

command_write() {
    ############################################################################
    # Opens today's daily file for writing. Sets user and group permissions
    # and possibly adds files to git, depending on user configuration.
    #
    # Globals:
    #    - doily_dir
    #    - public_dailies
    #    - doily_group
    #    - use_git
    #    - auto_commit
    # Environment:
    #    - EDITOR
    #    - USER
    # Args:
    #    - None.
    # Returns:
    #    - None.
    ############################################################################
    "${EDITOR:-nano}" "${doily_dir}/$(date +%F)"

    if [[ -n "${public_dailies}" ]]; then
        file_perms=644
        dir_perms=755
        doily_group="${USER}"
    elif [[ -n "${doily_group}" ]]; then
        file_perms=640
        dir_perms=750
    else
        file_perms=600
        dir_perms=700
        doily_group="${USER}"
    fi

    # Set permissions on everything, in case the config has changed.
    # (If you were wondering why the config file says not to use your home
    # directory as your Doily directory, this is why.)
    chmod "${dir_perms}" "${doily_dir}"
    chgrp "${doily_group}" "${doily_dir}"

    if [[ -z "$(find "${doily_dir}" -maxdepth 0 -empty)" ]]; then
        # These will error out if the directory is empty (for example if the text
        # editor was closed without saving), so we check first.
        # The method is taken from: http://stackoverflow.com/a/91769
        chmod "${file_perms}" "${doily_dir}"/*
        chgrp "${doily_group}" "${doily_dir}"/*
    fi

    if [[ -n "${use_git}" ]]; then
        # This will usually be excessive but harmless; if use_git is newly turned
        # on, though, it ensures the repo gets created and finds old dailies.
        git -C "${doily_dir}" init
        git -C "${doily_dir}" add "${doily_dir}"
        # The commit commands will return non-zero if we didn't commit anything,
        # but that's okay, so add an extra true to keep set -e from exiting.
        if [[ -n "${auto_commit}" ]]; then
            git -C "${doily_dir}" commit -m "Automatic commit from Doily." || true
        else
            git -C "${doily_dir}" commit || true
        fi
    fi
}

check_config() {
    ############################################################################
    # Creates or verifies the existence of the configuration file.
    #
    # Globals:
    #    - CONF_FILE
    #    - CONF_DIR
    # Args:
    #    - None.
    # Returns:
    #    - ECONFIG if the file doesn't exist and can't be created.
    ############################################################################
    if [[ -e "${CONF_FILE}" ]]; then
        return
    fi
    if [[ -e "${DEFAULT_CONF}" ]]; then
        mkdir -p "${CONF_DIR}"
        cp "${DEFAULT_CONF}" "${CONF_FILE}"
    else
        cat <<EOF

Couldn't find a configuration file for you!
No personal configuration in ${CONF_FILE}
No default configuration in ${DEFAULT_CONF}

This isn't supposed to happen. Please check http://github.com/relsqui/doily
for an example configuration file, then put it in:

${CONF_FILE}

EOF
        return "${ECONFIG}"
    fi
}

check_storage() {
    ############################################################################
    # Does some safety checking on the daily file storage directory.
    #
    # Config Vars:
    #    - doily_dir
    # Environment:
    #    - HOME
    # Args:
    #    - None.
    # Returns:
    #    - ESTORAGE if the directory is set inappropriately.
    #    - The return value of `mkdir -p` if it needs to be created.
    ############################################################################
    if [[ -z "${doily_dir}" ]]; then
        echo "No storage location set for Doily!"\
             "Please set one by running \`doily config\`." 1>&2
        return "${ESTORAGE}"
    fi
    if [[ "${doily_dir}" != /* ]]; then
        # If it starts with ~, the shell will expand it before it gets here.
        echo "Your Doily directory is set to a relative path, which is"\
             "unsafe. Please change it by running \`doily config\`." 1>&2
        return "${ESTORAGE}"
    fi
    if [[ "${doily_dir}" -ef "${HOME}" ]]; then
        echo "Your Doily directory is set to your home directory, which is"\
             "unsafe. Please change it by running \`doily config\`."\
             "${doily_dir} == ${HOME}" 1>&2
        return "${ESTORAGE}"
    fi
    if [[ ! -d "${doily_dir}" ]]; then
        mkdir -p "${doily_dir}"
        return $?
    fi
}

identify_dailyfile() {
    ############################################################################
    # Figure out which daily file a user is referring to, and return its
    # filename. The identifier can be in any format `date` knows how to
    # interpret, or the special case "last" to mean the most recent daily.
    #
    # Config Vars:
    #    - doily_dir
    # Args:
    #    - A string which can be identified as a daily file, either "last" or
    #      any format `date` can parse.
    # Echoes:
    #    - The filename of the appropriate daily file, if it exists, or an
    #      empty string otherwise.
    # Returns:
    #    - None.
    ############################################################################
    if find "${doily_dir}" -maxdepth 0 -empty >/dev/null; then
        # More than zero daily files exist.
        if [[ "$1" == "last" ]]; then
            # Echo the last (alphabetically) file in the directory, which
            # is the most recent unless it's been manually altered.
            echo "$(ls "${doily_dir}" | tail -n 1)"
            return
        else
            filename="$(date +%F --date="$1")"
            # Date will print nothing to stdin if it fails.
            if [[ -n "${filename}" ]]; then
                if [[ -e "${doily_dir}/${filename}" ]]; then
                    echo "${filename}"
                    return
                fi
            fi
        fi
    fi
    # We couldn't find it or it didn't exist.
    echo ""
}

run_command() {
    ############################################################################
    # Runs the specified command with the arguments given.
    #
    # Args:
    #    - The command to be run. Defaults to "write".
    #    - Zero or more arguments to the supplied command.
    # Returns:
    #    - ECOMMAND if the requested command doesn't exist.
    ############################################################################
    doily_command="$1"
    if [[ -z "${doily_command}" ]]; then
        doily_command="write"
    fi
    # This returns failure if the args are empty, which is actually OK.
    shift || true
    case "${doily_command}" in
        config) command_config ;;
        help) command_help ;;
        read) command_read "$@" ;;
        search) command_search "$@" ;;
        version) command_version ;;
        write) command_write ;;
        *)
            echo "Use \`doily help\` to see help and other commands."
            return "${ECOMMAND}"
            ;;
    esac
}

main() {
    check_config || return $?
    source "${CONF_FILE}"
    check_storage || return $?
    run_command "$@" || return $?
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    main "$@"
fi
